// Generated by CoffeeScript 1.6.3
(function() {
  var Provide, T, typecheck, wrapFunction,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  T = require('./t');

  typecheck = require('./typecheck');

  Provide = module.exports = {};

  Provide.struct = function(obj) {
    return (function(_super) {
      __extends(_Class, _super);

      _Class.types = obj;

      _Class["new"] = function(params) {
        if (!T.debug || typecheck.isStruct(this.types, params)) {
          return new this(params);
        } else {
          throw "type error";
        }
      };

      function _Class(params) {
        var key, val;
        for (key in params) {
          val = params[key];
          this[key] = val;
        }
      }

      return _Class;

    })(T.Struct);
  };

  wrapFunction = function(Type, f, self) {
    if (self == null) {
      self = null;
    }
    return function() {
      var ArgType, args, i, ret, _i, _ref, _ref1;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length !== Type.args.length) {
        throw new Error("mismatch: Arguments length");
      }
      for (i = _i = 0, _ref = Type.args.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        ArgType = (_ref1 = Type.args[i].types) != null ? _ref1 : Type.args[i];
        if (!typecheck.isStruct(ArgType, args[i])) {
          console.log(Type.args[i]);
          console.log(args[i]);
          throw new Error("Argument Error");
        }
      }
      ret = f.apply(self, args);
      if (!typecheck.isStruct(Type.returns, ret)) {
        throw new Error("Return Type Error");
      }
      return ret;
    };
  };

  Provide.def = function(Class, instance) {
    var Type, item, _ref;
    Type = (_ref = Class.types) != null ? _ref : Class;
    if (typecheck.isFunction(instance)) {
      return wrapFunction(Type, instance);
    }
    if (!T.debug || typecheck.isArray(Class)) {
      Class = Class[0];
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = instance.length; _i < _len; _i++) {
          item = instance[_i];
          _results.push((typeof Class["new"] === "function" ? Class["new"](item) : void 0) || item);
        }
        return _results;
      })();
    } else if (!T.debug || (typecheck.isStruct(Type, instance))) {
      return (typeof Class["new"] === "function" ? Class["new"](instance) : void 0) || instance;
    } else {
      throw new Error("instance: " + instance + "\ntype: " + Type);
    }
  };

  Provide.provide = function() {
    var global;
    global = typeof window !== "undefined" && window !== null ? window : global;
    global.def = Provide.def;
    return global.struct = Provide.struct;
  };

}).call(this);
